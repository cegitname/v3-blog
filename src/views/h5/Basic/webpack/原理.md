### 模块系统
主要解决模块的定义，依赖和导出。
原始 script 标签的弊端：
  1. 全局作用域下的变量冲突
  2. 文件只能按照顺序进行加载
  3. 必须主管的解决模块和代码库的依赖关系

因此衍生出很多模块化方案：
  1. commonjs 缺点：同步的加载方式，意味着阻塞加载
  2. AMD 缺点：阅读和书写比较困难。
  3. CMD 缺点：依赖spm打包，模块的加载逻辑偏重。
  4. ES6 缺点：原生浏览器未实现该标准

模块的加载和传输，如果每个文件都单独请求，回导致请求次数过多，导致启动速度过慢。
如果全部打包在一起请求 1 次，会导致流量浪费，初始化过程慢。
因此最佳方案是分块传输，按需懒加载，在实际用到模块的时候再增量更新。
要实现模块的按需加载，就需要对整个代码库的模块进行静态分析，编译打包的过程。
webpack 应运而生。

webpck 是一个模块打包器。它将模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。

### webpack 都能做什么
1. 代码拆分 webpack 有两种组织模块依赖的方式，同步和异步。 异步依赖作为分割点，形成一个新的块。每个异步区块都会作为一个文件被打包。
2. loader webpack 本身只能处理原生的 javascript 模块，loader 可以将各种类型的资源转成 javascript 模块。
3. 智能解析 可以解析各种格式的模块，commonjs,amd,es6 
4. 插件系统 可以开发和使用 webpack 插件

### 打包工具的核心原理
就是负责把一些分散的小模块，按照一定的规则整合成一个大模块的工具，并处理好模块之间的依赖关系。

- 以字符串形式读取文件的内容. 
-  现在我们试图找出这个文件依赖于哪个文件。虽然我们可以通过查看其内容来获取import字符串. 然而,这是一个非常笨重的方法，我们将使用JavaScript解析器来代替。
- JavaScript解析器是可以读取和理解JavaScript代码的工具，它们生成一个更抽象的模型,称为`ast (抽象语法树)(https://astexplorer.net)`。
- 定义数组，这个数组将保存这个模块依赖的模块的相对路径.
- 们遍历`ast`来试着理解这个模块依赖哪些模块，要做到这一点,我们需要检查`ast`中的每个 `import` 声明。
- `Ecmascript`模块相当简单,因为它们是静态的. 这意味着你不能`import`一个变量,或者有条件地`import`另一个模块。每次我们看到`import`声明时,我们都可以将其数值视为`依赖性`。
- 将依赖关系存入数组
- 通过递增简单计数器为此模块分配唯一标识符. 
- 我们使用`Ecmascript`模块和其他JavaScript,可能不支持所有浏览器。为了确保我们的程序在所有浏览器中运行,们将使用[babel]来进行转换。我们可以用`babel-preset-env``将我们的代码转换为浏览器可以运行的东西. 
- 返回有关此模块的所有信息.
- 现在我们可以提取单个模块的依赖关系，那么，我们将提取它的每一个依赖关系的依赖关系，并循环下去，直到我们了解应用程序中的每个模块以及他们是如何相互依赖的。
- 首先解析整个文件.  const mainAsset = createAsset(entry);
- 我们将使用queue来解析每个asset的依赖关系. 定义一个只有entry asset的数组.
- 循环遍历队列. 
- 最初 这个队列 只有一个asset,但是当我们迭代它时,我们会将额外的assert推入到queue中. 循环将在queue为空时终止. 
- 我们的每一个asset都有它所依赖模块的相对路径列表. 我们将重复它们,用我们的`createAsset() `函数解析它们,并跟踪此模块在此对象中的依赖关系.
- const dirname = path.dirname(asset.filename) 模块所在的目录，遍历其相关路径的列表。
- 遍历其相关路径的列表，可以通过将相对路径与父资源目录的路径连接,将相对路径转变为绝对路径.
- 解析asset,读取其内容并提取其依赖关系.
- 了解`asset`依赖取决于`child`这一点对我们来说很重要.通过给`asset.mapping`对象增加一个新的属性(值为child.id)来表达这种一一对应的关系.
- 最后,我们将`child`这个资产推入队列,这样它的依赖关系也将被迭代和解析.
- 接下来我们定义一个函数，传入上一步的graph，返回一个可以在浏览器上运行的包。
- 在我们到达该函数的主体之前,我们将构建一个作为该函数的参数的对象. 
- 请注意,我们构建的这个字符串被两个花括号 ({}) 包裹,因此对于每个模块,我们添加一个这种格式的字符串: `key: value,`.
- 图表中的每个模块在这个对象中都有一个entry. 我们用模块的id`作为`key`，用数组作为`value`
- 第一个参数是用函数包装的每个模块的代码. 这是因为模块应该被限定范围: 在一个模块中定义变量不会影响其他模块或全局范围. 
- 对于第二个参数,我们用`stringify`解析模块及其依赖之间的关系(也就是上文的asset.mapping). 解析后的对象看起来像这样: `{'./relative/path': 1}`.
- 这是因为我们模块的被转换后会通过相对路径来调用`require()`. 当调用这个函数时,我们应该能够知道依赖图中的哪个模块对应于该模块的相对路径. 
-  最后,使用`commonjs`,当模块需要被导出时,它可以通过改变exports对象来暴露模块的值. 

**总结**
  1. 从入口文件开始，对其进行依赖分析，生成 ast 
  2. 对其依赖递归进行分析 
  3. 构建出模块的依赖关系图 asset.mapping
  4. 根据关系图使用 CommonJs 规范构建出最终的代码


### 